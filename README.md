# CS300-DSA-Analysis-and-Design

1. What was the problem you were solving in the projects for this course?

   The project in this course was focused on helping a client create advising assistant software for the academic advisers of the CS department. The team was looking for a way to sort classes by course number, view a course plan, and view a course and its needed prerequisites. They wanted it to be an efficient program so finding efficient data structures was a focal point in the design process. Project One looked at analyzing some different data structures such as vectors, hash tables, and binary search trees and breaking down the memory and time complexities. Project Two was a working program that utilized the most efficient data structure from Project One to create a working C++ solution for the advising team. 

2. How did you approach the problem? Consider why data structures are important to understand.

   Data structures and their time complexities and memory use are very important to understand. In approaching the problem, itâ€™s important to look and see what areas of the code need to be minimized the most. If minimizing memory is the most important aspect, then you may pick a different data structure than if speed was the most important. It can also depend on how complex the solution needs to be. For a small project where low quantities of data are being stored and searched, the difference between a vector and binary search tree might not be that noticeable, however as that data grows, it will be. If the code remains small, it may not be worth the extra effort to make the binary search tree, and a vector will do just fine. Taking into consideration the requirements of the program is the first step to choosing a data structure(s) to use moving forward. 

4. How did you overcome any roadblocks you encountered while going through the activities or project?

   Roadblocks are often inevitable. Overcoming them can be challenging and time-consuming when you fail to take a uniform approach. I tested most of the project as it progressed so when I encountered errors, there was a smaller portion to check. Simple mistakes like mistaking a reference variable for a pointer or missing a parenthesis could take a while to find if not testing blocks of code as you go. When I can't find an error, getting up for a few minutes and coming back with fresh eyes still proves to be a solid tactic when I originally can't find a solution to a problem. Having a set outline for checking for problems when they do arise helps build a system that detects error spots more efficiently.
   
6. How has your work on this project expanded your approach to designing software and developing programs?

   In my recent projects, I have mostly stuck to the more basic data structures as my projects have been smaller and not too demanding to where I thought about using linked list, bst, and other data structures. I will, however, start to incorporate them moving forward as I am much more comfortable in how they operate, and the variety of abstract data types that become available when using them. There is certainly some improved performance when implementing them and there are a few places in past projects where I will go add them to test them out. The work with time complexity will also be very helpful. Being able to look at functions, programs, or lines, and being able to determine in big O which ones are more efficient will be useful in creating the most efficient code. I simply now have more tools under my belt in selecting and designing software designs which is always beneficial. 
   
8. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

   The continued practice of writing modular code was very present in the course. Modular code is very readable, easy to maintain, and adaptable. Non-modular code can be hard to read and change when needed. The increased use of structs help break objects apart and create a more adaptable and modular code. I will certainly continue to use this moving forward to increase modularity. Accurate and detailed comments help with readability and this skill was also practiced throughout the course. Readability also depends on accurate naming conventions for variables, classes, and functions and was another aspect of good practice that was important in this course.
